/*Lab 3 - Capture and Compare with the MSP432
 /Part 1 - Measuring distance using the proximity sensor
 /
 /Authors:
 /  Renzo Garza Motta
 /  Cianna Janicke
 /
 /Class: EGR 326
 /Section: 903
 /
 /Instructor:
 /  Dr. Nabeeh Kandalaft
 /
 /Description:
 /  This part will use the MSP432 Timer A in Capture mode to determine the length
 /  of a pulse generated by a proximity sensor (HC-SR04).
 /  The proximity sensor must be pre-triggered in order to generate a pulse so that
 /  distance to an object can be determined.
 /
 /  -Connect the proximity sensor to the MSP432 such that:
 /      -MSP output pin is connected via a 2N7000 MOSFET to provide a 5V signal to
 /       the HC-SR04 Trigger pin.
 /      -HC-SR04 echo pin outputs a 5V signal that has to be stepped down to ~3.3V
 /       via a voltage divider to act as an input signal to the MSP432. The design
 /       used a 68kOhm and 36kOhm resistors for the voltage divider.
 /      -Additionally, Vcc = 5V and GND = 0V.
 /  -The program is to print the distance measured by the proximity sensor every
 /   2 sec to the console using printf() -- stdio.h was included to print to console.
 */


/*  TIMER A LIBRARY
 *
 * Timer_A Introduction
 *  -16-bit (0xFFFF or 65535) timer/counter with up to seven capture/compare registers.
 *  -Supports multiple capture/compare, PWM outputs, and interval timing.
 *  -Extensive interrupt capabilities. Interrupts may be generated from the counter on
 *   overflow conditions and from each of the capture/compare registers.
 *
 *  x (x >= 0)in TAx indicates a Timer_A instantiation.
 *  n (n = 0 to 6) indicates capture/compare registers associated with the Timer_A instantiation
 *
 * 16-Bit Timer Counter
 *  -TAxR increments or decrements (depending on mode of operation) with each rising edge of the clock signal.
 *  -TAxR may be cleared by setting the TACLR bit.
 *  -It is recommended to stop the timer before modifying its operation to avoid errant operation conditions.
 *
 * Clock Source Select and Divider
 *  -The clock source is selected with the TASSEL bits. The selected clock source may be passed directly to
 *   the timer or divided by 2, 4, or 8, using the ID bits.
 *  -After programming the ID and TAIDEX bits, set the TACLR bit.
 *
 * Timer Mode Control
 *  -The timer has four modes of operation: stop, up, continuous, and up/down
 *
 * Up Mode
 *  -The up mode is used if the timer period must be different from 0FFFFh counts.
 *  -The TAxCCR0 CCIFG interrupt flag is set when the timer counts to the TAxCCR0 value.
 *  -Change the TAxCCR0 Register to change the period of the signal
 *
 * Continuous Mode
 *  -The timer repeatedly counts up to 0FFFFh and restarts from zero.
 *  -The capture/compare register TAxCCR0 works the same way as the other capture/compare registers.
 *  -The TAIFG interrupt flag is set when the timer counts from 0FFFFh to zero.
 *
 *  Use of Continuous Mode
 *  -This mode can be used to generate independent time intervals and output frequencies.
 *  -Up to n (where n = 0 to 6), independent time intervals or output frequencies can be generated using capture/compare registers.
 *  -Time intervals can be produced with other modes as well, where TAxCCR0 is used as the period register.
 *
 * Up/Down Mode
 *  -The up/down mode is used  if the timer period must be different from 0FFFFh counts, and if symmetrical pulse generation is needed.
 *  -The timer repeatedly counts up to the value of compare register TAxCCR0 and back down to zero. The period is twice the value in TAxCCR0.
 *  -Change the TAxCCR0 Register to change the period of the signal
 *
 * Capture/Compare Blocks
 *  -Up to seven identical capture/compare blocks, TAxCCRn (where n = 0 to 7), are present in Timer_A. Any of the blocks may be used to
 *   capture the timer data or to generate time intervals.
 *
 * Capture Mode
 *  -The capture mode is selected when CAP = 1 (in TAxCCTL0 to TAxCCTL6).
 *  -Capture mode is used to record time events. It can be used for speed computations or time measurements.
 *  -A capture occurs on the selected edge(CM) of the input signal (CCIxA or CCIxB)
 *  -If a capture occurs:
 *      -The timer value is copied into the TAxCCRn register.
 *      -The interrupt flag CCIFG is set.
 *
 *  -The inputs signal level can be read at any time from the CCI bit (in TAxCCTL0 to TAxCCTL6).
 *  -Setting the SCS bit to synchronize the capture signal with the timer clock is recommended to avoid a race condition
 *  -Only change capture input (CCI) when capture mode is disabled (CAP = 0 or CM = 0)
 *
 * Compare Mode
 *  -The capture mode is selected when CAP = 0 (in TAxCCTL0 to TAxCCTL6).
 *  -The compare mode is used to generate PWM signals or interrupts at specific time intervals.
 *  -When TAxR counts to the value in TAxCCRn (n represents the specific capture/compare register).
 *      -Interrupt flag CCIFG is set.
 *      -Internal signal EQUn = 1.
 *      -EQUn affects the output according to the output mode.
 *      -The input signal CCI is latched into SCCI
 *
 * Output Unit
 *  -Each capture/compare block contains an output unit. The output unit is used to generate output signals, such as PWM signals.
 *  -Each output unit has eight operating modes that generate signals based on the EQU0 and EQUn signals.
 *
 * Timer_A Interrupts
 *  -Two interrupt vectors are associated with the 16-bit Timer_A module:
 *      -TAxCCR0 interrupt vector for TAxCCR0 CCIFG
 *      -TAxIV interrupt vector for all other CCIFG flags and TAIFG
 *
 *  -In capture mode, any CCIFG flag is set when a timer value is captures in the associated TAxCCRn value.
 *
 *
 * Timer A Registers
 * Acronym                        Register Name
 * TAxCTL-------------------------Timer_Ax Control
 * TAxCCTL0 to TAxCCTL6-----------Timer_Ax Capture/Compare Control 0 to 6
 * TAxR---------------------------Timer_Ax Counter
 * TAxCCR0 to TAxCCR6-------------Timer Ax Capture/Compare 0 to 6
 * TAxIV--------------------------Timer_Ax Interrupt Vector
 * TAxEX0-------------------------Timer_Ax Expansion 0
 *
 //////////////////////////////////////////////////////////////////////////////
                                  TIMER_A Bits
 //////////////////////////////////////////////////////////////////////////////

  TAxCTL-------------------------Timer_Ax Control
    -Timer_A interrupt flag.
        #define TIMER_A_CTL_IFG_OFS                      ( 0)                            //!< TAIFG Bit Offset //
        #define TIMER_A_CTL_IFG                          ((uint16_t)0x0001)              //!< TimerA interrupt flag //
    // TIMER_A_CTL[IE] Bits //
    -Timer_A interrupt enable. This bit enables the TAIFG interrupt request.
        #define TIMER_A_CTL_IE_OFS                       ( 1)                            //!< TAIE Bit Offset //
        #define TIMER_A_CTL_IE                           ((uint16_t)0x0002)              //!< TimerA interrupt enable //
    // TIMER_A_CTL[CLR] Bits //
    -Timer_A clear. Setting this bit resets TAxR, the timer clock divider logic, and the count direction. The TACLR bit is automatically reset.
        #define TIMER_A_CTL_CLR_OFS                      ( 2)                            //!< TACLR Bit Offset //
        #define TIMER_A_CTL_CLR                          ((uint16_t)0x0004)              //!< TimerA clear //
    // TIMER_A_CTL[MC] Bits //
    -Mode control. Setting MCx = 00h when Timer_A is not in use conserves power.
        #define TIMER_A_CTL_MC_OFS                       ( 4)                            //!< MC Bit Offset //
        #define TIMER_A_CTL_MC_MASK                      ((uint16_t)0x0030)              //!< MC Bit Mask //
        #define TIMER_A_CTL_MC0                          ((uint16_t)0x0010)              //!< MC Bit 0 //
        #define TIMER_A_CTL_MC1                          ((uint16_t)0x0020)              //!< MC Bit 1 //
        #define TIMER_A_CTL_MC_0                         ((uint16_t)0x0000)              //!< Stop mode: Timer is halted //
        #define TIMER_A_CTL_MC_1                         ((uint16_t)0x0010)              //!< Up mode: Timer counts up to TAxCCR0 //
        #define TIMER_A_CTL_MC_2                         ((uint16_t)0x0020)              //!< Continuous mode: Timer counts up to 0FFFFh //
        #define TIMER_A_CTL_MC_3                         ((uint16_t)0x0030)              //!< Up/down mode: Timer counts up to TAxCCR0 then down to 0000h //
        #define TIMER_A_CTL_MC__STOP                     ((uint16_t)0x0000)              //!< Stop mode: Timer is halted //
        #define TIMER_A_CTL_MC__UP                       ((uint16_t)0x0010)              //!< Up mode: Timer counts up to TAxCCR0 //
        #define TIMER_A_CTL_MC__CONTINUOUS               ((uint16_t)0x0020)              //!< Continuous mode: Timer counts up to 0FFFFh //
        #define TIMER_A_CTL_MC__UPDOWN                   ((uint16_t)0x0030)              //!< Up/down mode: Timer counts up to TAxCCR0 then down to 0000h //
    // TIMER_A_CTL[ID] Bits //
    -Inputs divider. These bits along with the TAIDEX bits select the divider for the input clock.
        #define TIMER_A_CTL_ID_OFS                       ( 6)                            //!< ID Bit Offset //
        #define TIMER_A_CTL_ID_MASK                      ((uint16_t)0x00C0)              //!< ID Bit Mask //
        #define TIMER_A_CTL_ID0                          ((uint16_t)0x0040)              //!< ID Bit 0 //
        #define TIMER_A_CTL_ID1                          ((uint16_t)0x0080)              //!< ID Bit 1 //
        #define TIMER_A_CTL_ID_0                         ((uint16_t)0x0000)              //!< /1 //
        #define TIMER_A_CTL_ID_1                         ((uint16_t)0x0040)              //!< /2 //
        #define TIMER_A_CTL_ID_2                         ((uint16_t)0x0080)              //!< /4 //
        #define TIMER_A_CTL_ID_3                         ((uint16_t)0x00C0)              //!< /8 //
        #define TIMER_A_CTL_ID__1                        ((uint16_t)0x0000)              //!< /1 //
        #define TIMER_A_CTL_ID__2                        ((uint16_t)0x0040)              //!< /2 //
        #define TIMER_A_CTL_ID__4                        ((uint16_t)0x0080)              //!< /4 //
        #define TIMER_A_CTL_ID__8                        ((uint16_t)0x00C0)              //!< /8 //
    // TIMER_A_CTL[SSEL] Bits //
    -Timer_A clock source select
        #define TIMER_A_CTL_SSEL_OFS                     ( 8)                            //!< TASSEL Bit Offset //
        #define TIMER_A_CTL_SSEL_MASK                    ((uint16_t)0x0300)              //!< TASSEL Bit Mask //
        #define TIMER_A_CTL_SSEL0                        ((uint16_t)0x0100)              //!< SSEL Bit 0 //
        #define TIMER_A_CTL_SSEL1                        ((uint16_t)0x0200)              //!< SSEL Bit 1 //
        #define TIMER_A_CTL_TASSEL_0                     ((uint16_t)0x0000)              //!< TAxCLK //
        #define TIMER_A_CTL_TASSEL_1                     ((uint16_t)0x0100)              //!< ACLK //
        #define TIMER_A_CTL_TASSEL_2                     ((uint16_t)0x0200)              //!< SMCLK //
        #define TIMER_A_CTL_TASSEL_3                     ((uint16_t)0x0300)              //!< INCLK //
        #define TIMER_A_CTL_SSEL__TACLK                  ((uint16_t)0x0000)              //!< TAxCLK //
        #define TIMER_A_CTL_SSEL__ACLK                   ((uint16_t)0x0100)              //!< ACLK //
        #define TIMER_A_CTL_SSEL__SMCLK                  ((uint16_t)0x0200)              //!< SMCLK //
        #define TIMER_A_CTL_SSEL__INCLK                  ((uint16_t)0x0300)              //!< INCLK //





  TAxCCTL0 to TAxCCTL6-----------Timer_Ax Capture/Compare Control 0 to 6
    // TIMER_A_CCTLN[CCIFG] Bits //
    -Capture/compare interrupt flag.
        #define TIMER_A_CCTLN_CCIFG_OFS                  ( 0)                            //!< CCIFG Bit Offset //
        #define TIMER_A_CCTLN_CCIFG                      ((uint16_t)0x0001)              //!< Capture/compare interrupt flag //
    // TIMER_A_CCTLN[COV] Bits //
    -Capture overflow. This bit indicates a capture overflow occurred. COV must be reset with software.
        #define TIMER_A_CCTLN_COV_OFS                    ( 1)                            //!< COV Bit Offset //
        #define TIMER_A_CCTLN_COV                        ((uint16_t)0x0002)              //!< Capture overflow //
    // TIMER_A_CCTLN[OUT] Bits //
    -Output. For output mode 0, this bit directly controls the state of the output.
        #define TIMER_A_CCTLN_OUT_OFS                    ( 2)                            //!< OUT Bit Offset //
        #define TIMER_A_CCTLN_OUT                        ((uint16_t)0x0004)              //!< Output //
    // TIMER_A_CCTLN[CCI] Bits //
    -Capture/compare input. The selected input signal can be read by this bit.
        #define TIMER_A_CCTLN_CCI_OFS                    ( 3)                            //!< CCI Bit Offset //
        #define TIMER_A_CCTLN_CCI                        ((uint16_t)0x0008)              //!< Capture/compare input //
    // TIMER_A_CCTLN[CCIE] Bits //
    -Capture/compare interrupt enable. This bit enables the interrupt request of the corresponding CCIFG flag.
        #define TIMER_A_CCTLN_CCIE_OFS                   ( 4)                            //!< CCIE Bit Offset //
        #define TIMER_A_CCTLN_CCIE                       ((uint16_t)0x0010)              //!< Capture/compare interrupt enable //
    // TIMER_A_CCTLN[OUTMOD] Bits //
    -Output mode. Modes 2, 3, 6, and 7 are not useful for TAxCCR0 beacuse EQUx = EQU0
        #define TIMER_A_CCTLN_OUTMOD_OFS                 ( 5)                            //!< OUTMOD Bit Offset //
        #define TIMER_A_CCTLN_OUTMOD_MASK                ((uint16_t)0x00E0)              //!< OUTMOD Bit Mask //
        #define TIMER_A_CCTLN_OUTMOD0                    ((uint16_t)0x0020)              //!< OUTMOD Bit 0 //
        #define TIMER_A_CCTLN_OUTMOD1                    ((uint16_t)0x0040)              //!< OUTMOD Bit 1 //
        #define TIMER_A_CCTLN_OUTMOD2                    ((uint16_t)0x0080)              //!< OUTMOD Bit 2 //
        #define TIMER_A_CCTLN_OUTMOD_0                   ((uint16_t)0x0000)              //!< OUT bit value //
        #define TIMER_A_CCTLN_OUTMOD_1                   ((uint16_t)0x0020)              //!< Set //
        #define TIMER_A_CCTLN_OUTMOD_2                   ((uint16_t)0x0040)              //!< Toggle/reset //
        #define TIMER_A_CCTLN_OUTMOD_3                   ((uint16_t)0x0060)              //!< Set/reset //
        #define TIMER_A_CCTLN_OUTMOD_4                   ((uint16_t)0x0080)              //!< Toggle //
        #define TIMER_A_CCTLN_OUTMOD_5                   ((uint16_t)0x00A0)              //!< Reset //
        #define TIMER_A_CCTLN_OUTMOD_6                   ((uint16_t)0x00C0)              //!< Toggle/set //
        #define TIMER_A_CCTLN_OUTMOD_7                   ((uint16_t)0x00E0)              //!< Reset/set //
    // TIMER_A_CCTLN[CAP] Bits //
    -Capture mode
        #define TIMER_A_CCTLN_CAP_OFS                    ( 8)                            //!< CAP Bit Offset //
        #define TIMER_A_CCTLN_CAP                        ((uint16_t)0x0100)              //!< Capture mode //
    // TIMER_A_CCTLN[SCCI] Bits //
    -Synchronize capture/compare input. The selected CCI input signal is latched with the EQUx signal and can be read via this bit.
        #define TIMER_A_CCTLN_SCCI_OFS                   (10)                            //!< SCCI Bit Offset //
        #define TIMER_A_CCTLN_SCCI                       ((uint16_t)0x0400)              //!< Synchronized capture/compare input //
    // TIMER_A_CCTLN[SCS] Bits //
    -Synchronize capture source. This bit is used to synchronize the capture input signal with the timer clock.
        #define TIMER_A_CCTLN_SCS_OFS                    (11)                            //!< SCS Bit Offset //
        #define TIMER_A_CCTLN_SCS                        ((uint16_t)0x0800)              //!< Synchronize capture source //
    // TIMER_A_CCTLN[CCIS] Bits //
    -Capture/compare input select. These bits select the TAxCCR0 input signal.
        #define TIMER_A_CCTLN_CCIS_OFS                   (12)                            //!< CCIS Bit Offset //
        #define TIMER_A_CCTLN_CCIS_MASK                  ((uint16_t)0x3000)              //!< CCIS Bit Mask //
        #define TIMER_A_CCTLN_CCIS0                      ((uint16_t)0x1000)              //!< CCIS Bit 0 //
        #define TIMER_A_CCTLN_CCIS1                      ((uint16_t)0x2000)              //!< CCIS Bit 1 //
        #define TIMER_A_CCTLN_CCIS_0                     ((uint16_t)0x0000)              //!< CCIxA //
        #define TIMER_A_CCTLN_CCIS_1                     ((uint16_t)0x1000)              //!< CCIxB //
        #define TIMER_A_CCTLN_CCIS_2                     ((uint16_t)0x2000)              //!< GND //
        #define TIMER_A_CCTLN_CCIS_3                     ((uint16_t)0x3000)              //!< VCC //
        #define TIMER_A_CCTLN_CCIS__CCIA                 ((uint16_t)0x0000)              //!< CCIxA //
        #define TIMER_A_CCTLN_CCIS__CCIB                 ((uint16_t)0x1000)              //!< CCIxB //
        #define TIMER_A_CCTLN_CCIS__GND                  ((uint16_t)0x2000)              //!< GND //
        #define TIMER_A_CCTLN_CCIS__VCC                  ((uint16_t)0x3000)              //!< VCC //
    // TIMER_A_CCTLN[CM] Bits //
    -Capture Mode
        #define TIMER_A_CCTLN_CM_OFS                     (14)                            //!< CM Bit Offset //
        #define TIMER_A_CCTLN_CM_MASK                    ((uint16_t)0xC000)              //!< CM Bit Mask //
        #define TIMER_A_CCTLN_CM0                        ((uint16_t)0x4000)              //!< CM Bit 0 //
        #define TIMER_A_CCTLN_CM1                        ((uint16_t)0x8000)              //!< CM Bit 1 //
        #define TIMER_A_CCTLN_CM_0                       ((uint16_t)0x0000)              //!< No capture //
        #define TIMER_A_CCTLN_CM_1                       ((uint16_t)0x4000)              //!< Capture on rising edge //
        #define TIMER_A_CCTLN_CM_2                       ((uint16_t)0x8000)              //!< Capture on falling edge //
        #define TIMER_A_CCTLN_CM_3                       ((uint16_t)0xC000)              //!< Capture on both rising and falling edges //
        #define TIMER_A_CCTLN_CM__NONE                   ((uint16_t)0x0000)              //!< No capture //
        #define TIMER_A_CCTLN_CM__RISING                 ((uint16_t)0x4000)              //!< Capture on rising edge //
        #define TIMER_A_CCTLN_CM__FALLING                ((uint16_t)0x8000)              //!< Capture on falling edge //
        #define TIMER_A_CCTLN_CM__BOTH                   ((uint16_t)0xC000)              //!< Capture on both rising and falling edges //



    // TIMER_A_EX0[IDEX] Bits //
    -Input divider expansion. These bits along with the ID bits select the divider for the input clock.
        #define TIMER_A_EX0_IDEX_OFS                     ( 0)                            //!< TAIDEX Bit Offset //
        #define TIMER_A_EX0_IDEX_MASK                    ((uint16_t)0x0007)              //!< TAIDEX Bit Mask //
        #define TIMER_A_EX0_IDEX0                        ((uint16_t)0x0001)              //!< IDEX Bit 0 //
        #define TIMER_A_EX0_IDEX1                        ((uint16_t)0x0002)              //!< IDEX Bit 1 //
        #define TIMER_A_EX0_IDEX2                        ((uint16_t)0x0004)              //!< IDEX Bit 2 //
        #define TIMER_A_EX0_TAIDEX_0                     ((uint16_t)0x0000)              //!< Divide by 1 //
        #define TIMER_A_EX0_TAIDEX_1                     ((uint16_t)0x0001)              //!< Divide by 2 //
        #define TIMER_A_EX0_TAIDEX_2                     ((uint16_t)0x0002)              //!< Divide by 3 //
        #define TIMER_A_EX0_TAIDEX_3                     ((uint16_t)0x0003)              //!< Divide by 4 //
        #define TIMER_A_EX0_TAIDEX_4                     ((uint16_t)0x0004)              //!< Divide by 5 //
        #define TIMER_A_EX0_TAIDEX_5                     ((uint16_t)0x0005)              //!< Divide by 6 //
        #define TIMER_A_EX0_TAIDEX_6                     ((uint16_t)0x0006)              //!< Divide by 7 //
        #define TIMER_A_EX0_TAIDEX_7                     ((uint16_t)0x0007)              //!< Divide by 8 //
        #define TIMER_A_EX0_IDEX__1                      ((uint16_t)0x0000)              //!< Divide by 1 //
        #define TIMER_A_EX0_IDEX__2                      ((uint16_t)0x0001)              //!< Divide by 2 //
        #define TIMER_A_EX0_IDEX__3                      ((uint16_t)0x0002)              //!< Divide by 3 //
        #define TIMER_A_EX0_IDEX__4                      ((uint16_t)0x0003)              //!< Divide by 4 //
        #define TIMER_A_EX0_IDEX__5                      ((uint16_t)0x0004)              //!< Divide by 5 //
        #define TIMER_A_EX0_IDEX__6                      ((uint16_t)0x0005)              //!< Divide by 6 //
        #define TIMER_A_EX0_IDEX__7                      ((uint16_t)0x0006)              //!< Divide by 7 //
        #define TIMER_A_EX0_IDEX__8                      ((uint16_t)0x0007)              //!< Divide by 8 //
*/

#include "timerA.h"


