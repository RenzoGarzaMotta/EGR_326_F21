/*Lab 3 - Capture and Compare with the MSP432
 /Part 1 - Measuring distance using the proximity sensor
 /
 /Authors:
 /  Renzo Garza Motta
 /  Cianna Janicke
 /
 /Class: EGR 326
 /Section: 903
 /
 /Instructor:
 /  Dr. Nabeeh Kandalaft
 /
 /Description:
 /  This part will use the MSP432 Timer A in Capture mode to determine the length
 /  of a pulse generated by a proximity sensor (HC-SR04).
 /  The proximity sensor must be pre-triggered in order to generate a pulse so that
 /  distance to an object can be determined.
 /
 /  -Connect the proximity sensor to the MSP432 such that:
 /      -MSP output pin is connected via a 2N7000 MOSFET to provide a 5V signal to
 /       the HC-SR04 Trigger pin.
 /      -HC-SR04 echo pin outputs a 5V signal that has to be stepped down to ~3.3V
 /       via a voltage divider to act as an input signal to the MSP432. The design
 /       used a 68kOhm and 36kOhm resistors for the voltage divider.
 /      -Additionally, Vcc = 5V and GND = 0V.
 /  -The program is to print the distance measured by the proximity sensor every
 /   2 sec to the console using printf() -- stdio.h was included to print to console.
 */


/*  TIMER A LIBRARY
 /
 / Timer A Registers
 / Acronym                        Register Name
 / TAxCTL-------------------------Timer_Ax Control
 / TAxCCTL0 to TAxCCTL6-----------Timer_Ax Capture/Compare Control 0 to 6
 / TAxR---------------------------Timer_Ax Counter
 / TAxCCR0 to TAxCCR6-------------Timer Ax Capture/Compare 0 to 6
 / TAxIV--------------------------Timer_Ax Interrupt Vector
 / TAxEX0-------------------------Timer_Ax Expansion 0
 /
 /
 //////////////////////////////////////////////////////////////////////////////
                                  TIMER_A Bits
 //////////////////////////////////////////////////////////////////////////////
    // TIMER_A_CTL[IFG] Bits //
    #define TIMER_A_CTL_IFG_OFS                      ( 0)                            //!< TAIFG Bit Offset //
    #define TIMER_A_CTL_IFG                          ((uint16_t)0x0001)              //!< TimerA interrupt flag //
    // TIMER_A_CTL[IE] Bits //
    #define TIMER_A_CTL_IE_OFS                       ( 1)                            //!< TAIE Bit Offset //
    #define TIMER_A_CTL_IE                           ((uint16_t)0x0002)              //!< TimerA interrupt enable //
    // TIMER_A_CTL[CLR] Bits //
    #define TIMER_A_CTL_CLR_OFS                      ( 2)                            //!< TACLR Bit Offset //
    #define TIMER_A_CTL_CLR                          ((uint16_t)0x0004)              //!< TimerA clear //
    // TIMER_A_CTL[MC] Bits //
    #define TIMER_A_CTL_MC_OFS                       ( 4)                            //!< MC Bit Offset //
    #define TIMER_A_CTL_MC_MASK                      ((uint16_t)0x0030)              //!< MC Bit Mask //
    #define TIMER_A_CTL_MC0                          ((uint16_t)0x0010)              //!< MC Bit 0 //
    #define TIMER_A_CTL_MC1                          ((uint16_t)0x0020)              //!< MC Bit 1 //
    #define TIMER_A_CTL_MC_0                         ((uint16_t)0x0000)              //!< Stop mode: Timer is halted //
    #define TIMER_A_CTL_MC_1                         ((uint16_t)0x0010)              //!< Up mode: Timer counts up to TAxCCR0 //
    #define TIMER_A_CTL_MC_2                         ((uint16_t)0x0020)              //!< Continuous mode: Timer counts up to 0FFFFh //
    #define TIMER_A_CTL_MC_3                         ((uint16_t)0x0030)              //!< Up/down mode: Timer counts up to TAxCCR0 then down to 0000h //
    #define TIMER_A_CTL_MC__STOP                     ((uint16_t)0x0000)              //!< Stop mode: Timer is halted //
    #define TIMER_A_CTL_MC__UP                       ((uint16_t)0x0010)              //!< Up mode: Timer counts up to TAxCCR0 //
    #define TIMER_A_CTL_MC__CONTINUOUS               ((uint16_t)0x0020)              //!< Continuous mode: Timer counts up to 0FFFFh //
    #define TIMER_A_CTL_MC__UPDOWN                   ((uint16_t)0x0030)              //!< Up/down mode: Timer counts up to TAxCCR0 then down to 0000h //
    // TIMER_A_CTL[ID] Bits //
    #define TIMER_A_CTL_ID_OFS                       ( 6)                            //!< ID Bit Offset //
    #define TIMER_A_CTL_ID_MASK                      ((uint16_t)0x00C0)              //!< ID Bit Mask //
    #define TIMER_A_CTL_ID0                          ((uint16_t)0x0040)              //!< ID Bit 0 //
    #define TIMER_A_CTL_ID1                          ((uint16_t)0x0080)              //!< ID Bit 1 //
    #define TIMER_A_CTL_ID_0                         ((uint16_t)0x0000)              //!< /1 //
    #define TIMER_A_CTL_ID_1                         ((uint16_t)0x0040)              //!< /2 //
    #define TIMER_A_CTL_ID_2                         ((uint16_t)0x0080)              //!< /4 //
    #define TIMER_A_CTL_ID_3                         ((uint16_t)0x00C0)              //!< /8 //
    #define TIMER_A_CTL_ID__1                        ((uint16_t)0x0000)              //!< /1 //
    #define TIMER_A_CTL_ID__2                        ((uint16_t)0x0040)              //!< /2 //
    #define TIMER_A_CTL_ID__4                        ((uint16_t)0x0080)              //!< /4 //
    #define TIMER_A_CTL_ID__8                        ((uint16_t)0x00C0)              //!< /8 //
    // TIMER_A_CTL[SSEL] Bits //
    #define TIMER_A_CTL_SSEL_OFS                     ( 8)                            //!< TASSEL Bit Offset //
    #define TIMER_A_CTL_SSEL_MASK                    ((uint16_t)0x0300)              //!< TASSEL Bit Mask //
    #define TIMER_A_CTL_SSEL0                        ((uint16_t)0x0100)              //!< SSEL Bit 0 //
    #define TIMER_A_CTL_SSEL1                        ((uint16_t)0x0200)              //!< SSEL Bit 1 //
    #define TIMER_A_CTL_TASSEL_0                     ((uint16_t)0x0000)              //!< TAxCLK //
    #define TIMER_A_CTL_TASSEL_1                     ((uint16_t)0x0100)              //!< ACLK //
    #define TIMER_A_CTL_TASSEL_2                     ((uint16_t)0x0200)              //!< SMCLK //
    #define TIMER_A_CTL_TASSEL_3                     ((uint16_t)0x0300)              //!< INCLK //
    #define TIMER_A_CTL_SSEL__TACLK                  ((uint16_t)0x0000)              //!< TAxCLK //
    #define TIMER_A_CTL_SSEL__ACLK                   ((uint16_t)0x0100)              //!< ACLK //
    #define TIMER_A_CTL_SSEL__SMCLK                  ((uint16_t)0x0200)              //!< SMCLK //
    #define TIMER_A_CTL_SSEL__INCLK                  ((uint16_t)0x0300)              //!< INCLK //
    // TIMER_A_CCTLN[CCIFG] Bits //
    #define TIMER_A_CCTLN_CCIFG_OFS                  ( 0)                            //!< CCIFG Bit Offset //
    #define TIMER_A_CCTLN_CCIFG                      ((uint16_t)0x0001)              //!< Capture/compare interrupt flag //
    // TIMER_A_CCTLN[COV] Bits //
    #define TIMER_A_CCTLN_COV_OFS                    ( 1)                            //!< COV Bit Offset //
    #define TIMER_A_CCTLN_COV                        ((uint16_t)0x0002)              //!< Capture overflow //
    // TIMER_A_CCTLN[OUT] Bits //
    #define TIMER_A_CCTLN_OUT_OFS                    ( 2)                            //!< OUT Bit Offset //
    #define TIMER_A_CCTLN_OUT                        ((uint16_t)0x0004)              //!< Output //
    // TIMER_A_CCTLN[CCI] Bits //
    #define TIMER_A_CCTLN_CCI_OFS                    ( 3)                            //!< CCI Bit Offset //
    #define TIMER_A_CCTLN_CCI                        ((uint16_t)0x0008)              //!< Capture/compare input //
    // TIMER_A_CCTLN[CCIE] Bits //
    #define TIMER_A_CCTLN_CCIE_OFS                   ( 4)                            //!< CCIE Bit Offset //
    #define TIMER_A_CCTLN_CCIE                       ((uint16_t)0x0010)              //!< Capture/compare interrupt enable //
    // TIMER_A_CCTLN[OUTMOD] Bits //
    #define TIMER_A_CCTLN_OUTMOD_OFS                 ( 5)                            //!< OUTMOD Bit Offset //
    #define TIMER_A_CCTLN_OUTMOD_MASK                ((uint16_t)0x00E0)              //!< OUTMOD Bit Mask //
    #define TIMER_A_CCTLN_OUTMOD0                    ((uint16_t)0x0020)              //!< OUTMOD Bit 0 //
    #define TIMER_A_CCTLN_OUTMOD1                    ((uint16_t)0x0040)              //!< OUTMOD Bit 1 //
    #define TIMER_A_CCTLN_OUTMOD2                    ((uint16_t)0x0080)              //!< OUTMOD Bit 2 //
    #define TIMER_A_CCTLN_OUTMOD_0                   ((uint16_t)0x0000)              //!< OUT bit value //
    #define TIMER_A_CCTLN_OUTMOD_1                   ((uint16_t)0x0020)              //!< Set //
    #define TIMER_A_CCTLN_OUTMOD_2                   ((uint16_t)0x0040)              //!< Toggle/reset //
    #define TIMER_A_CCTLN_OUTMOD_3                   ((uint16_t)0x0060)              //!< Set/reset //
    #define TIMER_A_CCTLN_OUTMOD_4                   ((uint16_t)0x0080)              //!< Toggle //
    #define TIMER_A_CCTLN_OUTMOD_5                   ((uint16_t)0x00A0)              //!< Reset //
    #define TIMER_A_CCTLN_OUTMOD_6                   ((uint16_t)0x00C0)              //!< Toggle/set //
    #define TIMER_A_CCTLN_OUTMOD_7                   ((uint16_t)0x00E0)              //!< Reset/set //
    // TIMER_A_CCTLN[CAP] Bits //
    #define TIMER_A_CCTLN_CAP_OFS                    ( 8)                            //!< CAP Bit Offset //
    #define TIMER_A_CCTLN_CAP                        ((uint16_t)0x0100)              //!< Capture mode //
    // TIMER_A_CCTLN[SCCI] Bits //
    #define TIMER_A_CCTLN_SCCI_OFS                   (10)                            //!< SCCI Bit Offset //
    #define TIMER_A_CCTLN_SCCI                       ((uint16_t)0x0400)              //!< Synchronized capture/compare input //
    // TIMER_A_CCTLN[SCS] Bits //
    #define TIMER_A_CCTLN_SCS_OFS                    (11)                            //!< SCS Bit Offset //
    #define TIMER_A_CCTLN_SCS                        ((uint16_t)0x0800)              //!< Synchronize capture source //
    // TIMER_A_CCTLN[CCIS] Bits //
    #define TIMER_A_CCTLN_CCIS_OFS                   (12)                            //!< CCIS Bit Offset //
    #define TIMER_A_CCTLN_CCIS_MASK                  ((uint16_t)0x3000)              //!< CCIS Bit Mask //
    #define TIMER_A_CCTLN_CCIS0                      ((uint16_t)0x1000)              //!< CCIS Bit 0 //
    #define TIMER_A_CCTLN_CCIS1                      ((uint16_t)0x2000)              //!< CCIS Bit 1 //
    #define TIMER_A_CCTLN_CCIS_0                     ((uint16_t)0x0000)              //!< CCIxA //
    #define TIMER_A_CCTLN_CCIS_1                     ((uint16_t)0x1000)              //!< CCIxB //
    #define TIMER_A_CCTLN_CCIS_2                     ((uint16_t)0x2000)              //!< GND //
    #define TIMER_A_CCTLN_CCIS_3                     ((uint16_t)0x3000)              //!< VCC //
    #define TIMER_A_CCTLN_CCIS__CCIA                 ((uint16_t)0x0000)              //!< CCIxA //
    #define TIMER_A_CCTLN_CCIS__CCIB                 ((uint16_t)0x1000)              //!< CCIxB //
    #define TIMER_A_CCTLN_CCIS__GND                  ((uint16_t)0x2000)              //!< GND //
    #define TIMER_A_CCTLN_CCIS__VCC                  ((uint16_t)0x3000)              //!< VCC //
    // TIMER_A_CCTLN[CM] Bits //
    #define TIMER_A_CCTLN_CM_OFS                     (14)                            //!< CM Bit Offset //
    #define TIMER_A_CCTLN_CM_MASK                    ((uint16_t)0xC000)              //!< CM Bit Mask //
    #define TIMER_A_CCTLN_CM0                        ((uint16_t)0x4000)              //!< CM Bit 0 //
    #define TIMER_A_CCTLN_CM1                        ((uint16_t)0x8000)              //!< CM Bit 1 //
    #define TIMER_A_CCTLN_CM_0                       ((uint16_t)0x0000)              //!< No capture //
    #define TIMER_A_CCTLN_CM_1                       ((uint16_t)0x4000)              //!< Capture on rising edge //
    #define TIMER_A_CCTLN_CM_2                       ((uint16_t)0x8000)              //!< Capture on falling edge //
    #define TIMER_A_CCTLN_CM_3                       ((uint16_t)0xC000)              //!< Capture on both rising and falling edges //
    #define TIMER_A_CCTLN_CM__NONE                   ((uint16_t)0x0000)              //!< No capture //
    #define TIMER_A_CCTLN_CM__RISING                 ((uint16_t)0x4000)              //!< Capture on rising edge //
    #define TIMER_A_CCTLN_CM__FALLING                ((uint16_t)0x8000)              //!< Capture on falling edge //
    #define TIMER_A_CCTLN_CM__BOTH                   ((uint16_t)0xC000)              //!< Capture on both rising and falling edges //
    // TIMER_A_EX0[IDEX] Bits //
    #define TIMER_A_EX0_IDEX_OFS                     ( 0)                            //!< TAIDEX Bit Offset //
    #define TIMER_A_EX0_IDEX_MASK                    ((uint16_t)0x0007)              //!< TAIDEX Bit Mask //
    #define TIMER_A_EX0_IDEX0                        ((uint16_t)0x0001)              //!< IDEX Bit 0 //
    #define TIMER_A_EX0_IDEX1                        ((uint16_t)0x0002)              //!< IDEX Bit 1 //
    #define TIMER_A_EX0_IDEX2                        ((uint16_t)0x0004)              //!< IDEX Bit 2 //
    #define TIMER_A_EX0_TAIDEX_0                     ((uint16_t)0x0000)              //!< Divide by 1 //
    #define TIMER_A_EX0_TAIDEX_1                     ((uint16_t)0x0001)              //!< Divide by 2 //
    #define TIMER_A_EX0_TAIDEX_2                     ((uint16_t)0x0002)              //!< Divide by 3 //
    #define TIMER_A_EX0_TAIDEX_3                     ((uint16_t)0x0003)              //!< Divide by 4 //
    #define TIMER_A_EX0_TAIDEX_4                     ((uint16_t)0x0004)              //!< Divide by 5 //
    #define TIMER_A_EX0_TAIDEX_5                     ((uint16_t)0x0005)              //!< Divide by 6 //
    #define TIMER_A_EX0_TAIDEX_6                     ((uint16_t)0x0006)              //!< Divide by 7 //
    #define TIMER_A_EX0_TAIDEX_7                     ((uint16_t)0x0007)              //!< Divide by 8 //
    #define TIMER_A_EX0_IDEX__1                      ((uint16_t)0x0000)              //!< Divide by 1 //
    #define TIMER_A_EX0_IDEX__2                      ((uint16_t)0x0001)              //!< Divide by 2 //
    #define TIMER_A_EX0_IDEX__3                      ((uint16_t)0x0002)              //!< Divide by 3 //
    #define TIMER_A_EX0_IDEX__4                      ((uint16_t)0x0003)              //!< Divide by 4 //
    #define TIMER_A_EX0_IDEX__5                      ((uint16_t)0x0004)              //!< Divide by 5 //
    #define TIMER_A_EX0_IDEX__6                      ((uint16_t)0x0005)              //!< Divide by 6 //
    #define TIMER_A_EX0_IDEX__7                      ((uint16_t)0x0006)              //!< Divide by 7 //
    #define TIMER_A_EX0_IDEX__8                      ((uint16_t)0x0007)              //!< Divide by 8 //
*/

#ifndef TIMERA_H_
#define TIMERA_H_



#endif // TIMERA_H_ //
