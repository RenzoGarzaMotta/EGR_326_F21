/*Lab 4 - Interfacing a Keypad and Rotary Encoder with the MSP432
 *Part 2 - Detecting nob direction with the rotary encoder
 *
 *Authors:
 *  Renzo Garza Motta
 *  Cianna Janicke
 *
 *Class: EGR 326
 *Section: 903
 *
 *Instructor:
 *  Dr. Nabeeh Kandalaft
 *
 *Description:
 *  This part will allow for the user to spin the encoder a random number of "clicks".
 *  Upon pressing the encoder button, the console will display the accumulated number of clicks, along
 *  with the resulting direction (CW or CCW)
 *
 *  The continuous rotary encoder has positions and a built in push button switch. It is popular in auto
 *  entertainment systems. The outputs are based on 2-bit GRAY CODE which can be used for detecting
 *  rotation direction and magnitude.
 *
 *
 *  -Connect the rotary encoder to the MSP432 I/O port pins as designed in the Prelab exercise
 *  -Using an oscilloscope, capture the waveforms generated by the CLK and DT pins for both CW and CCW
 *   rotations. Only one or two cycles are necessary in the capture. Both signals shoud be on the same display.
 *  -Design your code to count pulses as the encoder is turned. CW pulses are counted separate from CCW pulses.
 *  -If the user presses the pushbutton switch, the cumulative pulse count (Absolute value (CW-CCW)) should be
 *   displayed, along with the resulting cumulative direction (either CW or CCW) to the console.
 *
 *   |       FRONT      |
 *   |   ______         |
 *   |  |      |        |
 *   |_GND_5V_SW_DT_CLK_|
 *      |  |  |  |  |
 *      |  |  |  |  |____P2.5 (2N7000 Level shifter 5V to 3.3V)
 *      |  |  |  |_______P2.6 (2N7000 Level shifter 5V to 3.3V)
 *      |  |  |__________P2.4 (Internally pulled-up)
 *      |  |_____________5V
 *      |________________GND
 *
 */

#include "msp.h"
#include <math.h>
#include <stdio.h>
#include "macros.h"
#include "systick.h"

void gpioSetup(void);           //This function sets up all gpio for the project
void setupTimerA(void);         //This function sets up TimerA that detects changes in the encoder
uint8_t debounceBtn1(void);     //This function is a debounce for the encoder built-in button

uint8_t btn1Flag = 0;           //Flag to indicate encoder button has been pressed
uint8_t CWflag, CCWflag;        //Flag to indicate if a CW or CCW rotation has taken place
int CW, CCW;                    //These counters keep track of rotation count in the CW or CCW direction
int clkState, DTState;          //These variables were use to view CLK and DT state during debugger session

void main(void){
	WDT_A->CTL = WDT_A_CTL_PW | WDT_A_CTL_HOLD;		// stop watchdog timer
	int pulseCount = 0;                             //Stores the absolute value of the CW vs CCW difference

	sysTickSetup();                                 //Set up SysTick Timer to use Delays
    gpioSetup();                                    //Set up project GPIO
    setupTimerA();                                  //Set up Rotary Encoder Timer A

    NVIC->ISER[0] = 1 << (TA0_N_IRQn & 31);         //Set up TimerA0.N interrupt
    NVIC->ISER[1] = 1 << (PORT2_IRQn & 31);         //Set interrupts for Port 2
    __enable_irq();                                 //Enable all interrupts

    while(1){
        if(btn1Flag){                               //Check if the Encoder button has been pressed
            pulseCount = fabs(CW-CCW);
            if(CW > CCW){
                printf("%d CW\n", pulseCount);      //Print the difference in clicks and what net direction the encoder was moved
                fflush(stdout);                     //Flush buffer
            }else{
                printf("%d CCW\n", pulseCount);     //Print the difference in clicks and what net direction the encoder was moved
                fflush(stdout);                     //Flush buffer
            }
            CW = 0;                                 //Clear CW counter
            CCW = 0;                                //Clear CCW counter
            btn1Flag = 0;                           //Clear Encoder button flag
        }
        if(CWflag){                                 //Check if a CW rotation was detected
            CW++;                                   //Increase the CW click counter
            CWflag = 0;                             //Clear flag to avoid faulty click counting
        }
        if(CCWflag){                                //Check if a CCW rotation was detected
            CCW++;                                  //Increase the CCW click counter
            CCWflag = 0;                            //Clear flag to avoid faulty click counting
        }
    }
}

void TA0_N_IRQHandler(void){
    msDelay(2);
    clkState = ENCODER_PORT->IN & CLK;                  //Store clock state when an event in TimerA happens
    DTState = ENCODER_PORT->IN & DT;                    //Store DT state when an event in TimerA happens

    if((ENCODER_PORT->IN & CLK) == 0){                  //Check if falling edge was triggered
        if((ENCODER_PORT->IN & DT) == 0x00000020){      //Check if DT is 1
            CWflag = 1;                                 //If DT is a 1 when CLK encounters a falling edge, the encoder is rotating CW
        }else if((ENCODER_PORT->IN & DT) == 0){         //Check if DT is 0
            CCWflag = 1;                                //If DT is a 0 when CLK encounters a falling edge, the encoder is rotating CCW
        }
    }else if((ENCODER_PORT->IN & CLK) == 0x00000040){   //Check if rising edge was triggered
        if((ENCODER_PORT->IN & DT) == 0x00000020){      //Check if DT is 1
            CCWflag = 1;                                //If DT is a 1 when CLK encounters a rising edge, the encoder is rotating CCW
        }else if((ENCODER_PORT->IN & DT) == 0){         //Check if DT is 0
            CWflag = 1;                                 //If DT is a 0 when CLK encounters a rising edge, the encoder is rotating CW
        }
    }

    TIMER_A0->CCTL[3] &=~ TIMER_A_CCTLN_CCIFG;          //Clear TimerA0 interrupts
}

void PORT2_IRQHandler(void){
    int i;
    if(ENCODER_PORT->IFG & SW){
        for(i = 0; i < 75; i++){        //Cycle through for-loop to check state of button bounce
            if(debounceBtn1()){         //Check that button1 has been pressed
                btn1Flag = 1;           //Set button1 flag to indicate that button1 was pressed
            }
        }
        ENCODER_PORT->IFG &=~ SW;       //Clear interrupt flag for button pin
    }
    ENCODER_PORT->IFG = 0;              //Clear the entire port interrupt flag
}

uint8_t debounceBtn1(void){                                             //Debounce function for button1
    static uint16_t State1 = 0;                                         //Current debounce status
    State1 = (State1 << 1) | (ENCODER_PORT->IN & SW)>>1 | 0x8000;       //Shift state to indicate bounce
    if(State1==0x8000)return 1;                                         //indicates 0 level is
    return 0;
}

void setupTimerA(void){
    ENCODER_PORT->SEL0 |= CLK;                         //Enable Secondary function in Encoder CLK pin
    ENCODER_PORT->SEL1 &=~ CLK;

    TIMER_A0->CTL |= (TIMER_A_CTL_SSEL__SMCLK|         //Timer_A clock source: SMCLK
                      TIMER_A_CTL_MC__CONTINUOUS|      //Continuous mode: Timer counts to 0FFFFh
                      TIMER_A_CTL_ID__1|               //Input Divider of /1
                      TIMER_A_CTL_CLR);                //Clear TA0R

    //Set up P2.6 Timer A
    TIMER_A0->CCTL[3] = (TIMER_A_CCTLN_CM__BOTH|       //Capture on both rising and falling edges
                         TIMER_A_CCTLN_CCIS__CCIA|     //Capture/Compare Input Select: CCIxA
                         TIMER_A_CCTLN_CCIE|           //capture/Compare Interrupt Enable
                         TIMER_A_CCTLN_CAP|            //Enable Capture mode
                         TIMER_A_CCTLN_SCS);           //Synchronize Capture source
}

void gpioSetup(void){
    ENCODER_PORT->SEL0 &=~ ENCODER;     //Set up encoder pins as GPIO
    ENCODER_PORT->SEL1 &=~ ENCODER;

    ENCODER_PORT->DIR &=~ ENCODER;      //Set up encoder pins as inputs

    ENCODER_PORT->REN |= SW;            //Enable internal resistor
    ENCODER_PORT->OUT |= SW;            //Set internal resistor to pull-up

    ENCODER_PORT->IES |= SW;            //Interrupt edge select high-to-low edge (falling edge)

    ENCODER_PORT->IE |= SW;             //Enable port interrupt

    ENCODER_PORT->IFG = 0;              //Clear interrupt flag (just in case)
}
